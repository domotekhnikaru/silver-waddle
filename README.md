## Описание и цель 

В большом помещении (например, торговый центр) возле каждого входа и выхода есть устройство, которое считает и отдает 
информацию о количестве входящих и выходящих людей. Данное устройство интегрировано с нашим проектом и умеет передавать 
нам эти данные.

**Цель** - сделать вывод для клиентов информации о загрузке помещения

Пример для понимания
![Картинка](https://raw.githubusercontent.com/domotekhnikaru/silver-waddle/main/public/image.jpg)

## ТЗ

### Реализовать api для получения (сохранения в базе сайта) информации:
   
   Запрос
```
GET/POST /input?time=12333333&diff=-4
```
Ответ всегда 
```
{success: true}
```
- time - время в формате unix timestamp
- diff - изменение количества человек в помещении (человек, прошедших через дверь за определенную секунду). Положительное - зашло N человек, отрицательное - вышло N человек.
- С одним и тем же time может приходить несколько разных событий (из разных источников). 
- Для каких-то time (секунд, минут, часов) изменения (запросы) могут отсутствовать.
- Для удобства можно считать, что каждый следующий запрос имеет точно такой же или больший time.
- Учитываем только запросы, приходящие с 10:00 по 21:59:59 включительно (по часовому поясу Asia/Vladivostok).  Остальные запросы можно сохранять, но считать их в дневной/суточной загруженности не нужно. 
- **Каждый день начинается 10:00 c нулевого количества посетителей.**

### Реализовать api для вывода графиков:

GET /hours - почасовой график загрузки в течение дня
Нужно вернуть объект (php массив), где ключом является номер часа (10-21), а значением - строка low/medium/high, 
означающая среднюю загрузку помещения в указанный период ("11" означает период 11-12, т.е. учитываются данные за 11:00:00-11:59:59) в течение суток по всем дням, имеющимся в базе.
```
{"byHours": {"10": "high", "11": "low", "12": "low",..., "21":"high"}}
```

GET /days - график загрузки по дням (числам) месяца
Нужно вернуть объект (php массив), где ключом является номер дня месяца (1-31), а значением - строка low/medium/high,
означающая среднюю загрузку помещения в течение дня для определенного дня(числа) месяца всем месяцам, имеющимся в базе.

```
{"byDays": {"1": "high", "2": "low", "3": "low",..., "31":"high"}}
```

Загрузка считается так:

На конец каждой **минуты** (XX:XX:59) фиксируется количество человек, находящихся в помещении.

Средняя загрузка часа считается как среднее арифметическое от 60 минутных загрузок (например, с 10:00 по 10:59 включительно) 
каждого дня (1, 2, 3...  января, февраля...) по которому есть информация.

Средняя загрузка дня считается как среднее арифметическое среди всех минутных загрузок в течение определенного дня (числа) месяца,
т.е. средней загрузки за 1 января, 1 февраля, 1 марта и т.д. по всем имеющимся данным.

*Использовать данные по текущей минуте/часу/дню не обязательно, можно использовать данные за предыдущий период (т.е. не учитывать последний час или последний день в любой из выгрузок), если это облегчит реализацию*

````
Пример 19.03

time=1710806449 diff=10 // 10:00:49
time=1710806449 diff=-4 // 10:00:49
time=1710806452 diff=-4 // 10:00:52
time=1710806462 diff=3 // 10:01:02

На 10:00:00 (начало дня) у нас 0 посетителей в помещении
На 10:00:49 19.03 у нас 10-4 = 6 посетителей 
на 10:00:52 - 6-4 = 2 посетителя

на 10:01:03 = 2+3 = 5 посетителей

Больше других изменений за день нет вообще

итого:
на 10:00 = 2 посетителя (последнее состояние в этой минуте)
на 10:01 = 5 (последнее состояние в этой минуте)
на 10:02...10:59 = 5
на 11:00.. 11:59 = 5 (без изменений)
на 12:00.. 21:59 = 5 (без изменений)

Среднее по 10-11 часам 19.03 = (2 + 5*59.. т.к. остальное время кол-во посетителей не менялось, т.е как было так и осталось 5 человек)/60 = 4,95 (можно округлить)
Среднее по 11-12 часам 19.03 = 5*60/60  = 5
и т.д. 

Среднее по дню 19.03 - (4.95 + 5*11) / 12 = 4.995
Среднее по дню 19.02 = 2 (данные в базе, вне вышеописанного примера)
Среднее по дню 19.01 = 2

Среднее по 19 числу = (2+2+4.995) / 3 = ~3

Среднее по 19.03 10-11 часов = 4.95
Среднее по 18.03 10-11 часов = 3
Среднее по 17.01 10-11 часов = 1

Среднее по 10-11 = (4.95+3+1)/3 = ~3
````

В выводе апи нужно вернуть загрузку относительно некоторой константы (например, 10)
- если средняя загрузка до 50% (включительно) от нее - low
- если от 50% до 80% - medium
- если больше 80% (включая все, что больше 100%) - high

Среднее по дню можно считать по сырым данным, по данным за каждую минуту или по среднему за час.

## Не нужно делать
- Фронтенд в любом виде (апи достаточно).
- Кэширование в быстрое хранилище (memcache/redis). 
- Не нужно хранить какие-то данные исключительно для "доработок и нового функционала" - описанное тз законченное, никакой 
новый функционал (например, таблицы и графики по каждому дню) не потребуются никогда.
- Валидацию, проверку корректности данных.

## Как нужно делать

1. Склонировать / форкнуть проект на гитхабе
2. Установить php8.2 / 8.3
3. Установить MySQL 8+ (или MariaDB или postgresql, не принципиально)
4. В .env раскомментировать и заполнить данные для подключения к базе
5. Запустить php composer.phar install
6. Обдумать задачу
7. Сделать структуру базы через миграции или просто файлом .sql в корне проекта (без данных)
8. Не забыть подходящие индексы (если нужны)
9. Добавить функционал в контроллер InputController (api сохранения данных). Данные "приходят" в методах $request. Поставить true в Response
10. Добавить функционал в методы контролера OutputController (апи для вывода) в Response в нужном (из примера) формате.
11. Если в задаче требуется что-то предрассчитать (с какой-то периодичностью) - можно создать консольную команду (пример TestCommand) php artisan make:command или методом CopyPaste из TestCommand. Команда запускается php artisan commandname
12. Запушить на github
13. Отправить ссылку

#### Запуск сервера 

Для тестирования и запуска приложения не нужно настраивать nginx/apache/php-fpm. Встроенный сервер запускается командой
**php artisan serve **

Для формирования запросов можно использовать чистый sql и методы ->select /selectOne / update / delete или querybuilder (не нужно использовать модели и orm).
Форматирование желательно PSR12 (можно настроить в phpstorm/vscode.. но это не обязательно!), переменные в $camelCase, остальное можно по аналогии. 
Не нужно использовать хранимые процедуры, pl/pgsql, триггеры, view. Можно использовать (если нужно) транзакции, jsonb, запросы с аггрерациями и прочим функционалом, позволяющим подсчитывать максимум данных в базе, а не на пхп.
Несмотря на округление итогового результата, желательно (но не обязательно) не терять данные о посетителях. Например, хранить все данные за день и одном большом json'е, загружать его на php, обновлять и апдейтить полностью - плохая идея, т.к. можно потерять данные, записанные параллельно выполнявшимся запросом.
Логику можно написать в контроллерах/классе задания (Command/*) либо вынести в отдельные классы (если это не сильно увеличит срок реализации)

















